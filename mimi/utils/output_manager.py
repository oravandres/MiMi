"""Utilities for managing output files and directories for generated software."""

import os
import re
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional, Union
import sys

# Add vendor directory to path to find loguru
vendor_path = Path(__file__).parent.parent / "vendor"
if vendor_path.exists() and str(vendor_path) not in sys.path:
    sys.path.append(str(vendor_path))

# Import logger for debugging
from loguru import logger

def sanitize_filename(name: str) -> str:
    """Sanitize a string to be used as a filename.
    
    Args:
        name: The string to sanitize.
        
    Returns:
        A sanitized filename-safe string.
    """
    # First, preserve the original capitalization
    original_name = name
    
    # Special case for index.html
    if name.lower() == "index.html":
        return "index.html"
    
    # Special case for common web files
    if name.lower() in ["game.js", "main.js", "app.js", "styles.css", "style.css", "favicon.ico"]:
        return name.lower()
    
    # Handle common malformed patterns
    if name.startswith('.') and name not in ['.gitignore', '.env']:
        # Classes in CSS incorrectly used as filenames (like .header or .game-container)
        if '_css' in name.lower() or 'style' in name.lower():
            return 'style.css'
        elif 'script' in name.lower() or '_js' in name.lower():
            return 'script.js'
        else:
            name = name[1:]  # Remove leading dot
    
    # Fix repeated extensions (like .css.css)
    if '.' in name:
        parts = name.split('.')
        # If the same extension appears twice at the end
        if len(parts) >= 3 and parts[-1] == parts[-2]:
            return '.'.join(parts[:-1])
    
    # Clean up filename patterns generated by LLMs
    name = re.sub(r'^file_+', '', name)  # Remove 'file_' prefix
    name = re.sub(r'^body__', '', name)  # Remove 'body__' prefix
    name = re.sub(r'^[_\s]+', '', name)  # Remove leading underscores/spaces
    name = re.sub(r'[\s_]+$', '', name)  # Remove trailing underscores/spaces

    # Remove special prefixes/suffixes that agents often generate
    name = re.sub(r'__(html|css|js)$', r'.\1', name)  # __html -> .html
    
    # Replace spaces and special characters
    sanitized = re.sub(r'[^\w\s\-.]', '', name)  # Allow periods for file extensions
    sanitized = re.sub(r'[\s]+', '_', sanitized)
    
    # Make sure we preserve existing extensions
    if '.' in original_name and not re.search(r'\.\w+$', sanitized):
        extension = original_name.split('.')[-1]
        if re.match(r'^[a-zA-Z0-9]+$', extension):  # Only if it looks like a real extension
            sanitized += '.' + extension
    
    # Handle specific game files
    if 'flappybird' in sanitized.lower() or 'flappy_bird' in sanitized.lower():
        if 'js' in sanitized.lower() or not '.' in sanitized:
            return 'flappy-bird.js'
        elif 'css' in sanitized.lower():
            return 'flappy-bird.css'
        elif 'html' in sanitized.lower():
            return 'index.html'
    
    # Make sure we have a valid extension for common file types if no extension found
    if not re.search(r'\.\w+$', sanitized):
        # Try to infer extension from content or context
        if '_css' in sanitized or 'style' in sanitized.lower():
            sanitized += '.css'
        elif '_js' in sanitized or 'script' in sanitized.lower():
            sanitized += '.js'
        elif '_html' in sanitized:
            sanitized += '.html'
        elif '_py' in sanitized:
            sanitized += '.py'
    
    # Special case for handling doctype_html pattern
    if "doctype_html" in sanitized.lower() or sanitized.lower() == "index_html.html":
        return "index.html"
    
    # Fix any remaining issues with leading/trailing characters
    sanitized = sanitized.strip('._-')
    
    # If we end up with an empty string, use a default
    if not sanitized:
        return "file.txt"
        
    return sanitized

def get_standard_header(filename: str, project_name: str) -> str:
    """Generate a standard file header with licensing and information.
    
    Args:
        filename: The name of the file.
        project_name: The name of the project.
        
    Returns:
        A formatted header string.
    """
    file_ext = Path(filename).suffix.lower()
    
    # Choose comment style based on file extension
    if file_ext in ['.js', '.ts', '.css', '.java', '.c', '.cpp', '.h', '.hpp']:
        comment_start = '/**'
        comment_line = ' * '
        comment_end = ' */'
    elif file_ext in ['.py']:
        comment_start = '"""'
        comment_line = ''
        comment_end = '"""'
    elif file_ext in ['.html', '.xml']:
        comment_start = '<!--'
        comment_line = ' '
        comment_end = '-->'
    else:
        # Default to hash comments
        comment_start = '#'
        comment_line = '# '
        comment_end = '#'

    creation_date = datetime.now().strftime("%Y-%m-%d")
    
    header = f"{comment_start}\n"
    if comment_line:
        header += f"{comment_line}File: {filename}\n"
        header += f"{comment_line}Project: {project_name}\n"
        header += f"{comment_line}Created: {creation_date}\n"
        header += f"{comment_line}Description: \n"
    else:
        header += f"File: {filename}\n"
        header += f"Project: {project_name}\n"
        header += f"Created: {creation_date}\n"
        header += f"Description: \n"
    header += f"{comment_end}\n\n"
    
    return header

def create_output_directory(project_title: str, timestamp: Optional[str] = None) -> Path:
    """Create an output directory for the generated software.
    
    This function creates a directory structure for the project output,
    using the project title and an optional timestamp.
    
    Args:
        project_title: The title of the project.
        timestamp: Optional timestamp to use in the directory name.
            If not provided, the current time will be used.
            
    Returns:
        Path to the created output directory.
    """
    # Add call stack debugging to trace where this function is being called from
    import traceback
    stack = traceback.extract_stack()
    caller = stack[-2]  # Get caller info
    logger.debug(f"CREATE DIR TRACE: create_output_directory called from {caller.filename}:{caller.lineno}")
    
    # Trace the last 3 calls in stack for more context
    stack_trace = "\n".join([f"  {frame.filename}:{frame.lineno} - {frame.name}" for frame in stack[-4:-1]])
    logger.debug(f"CREATE DIR STACK:\n{stack_trace}")
    
    # Log project title and timestamp parameters
    logger.debug(f"Creating output directory for project: '{project_title}'")
    
    if timestamp is None:
        # Get the current time for folder naming
        now = datetime.now()
        timestamp = now.strftime("%Y%m%d_%H%M%S")
        
    logger.debug(f"Timestamp: {timestamp}, Sanitized title: {sanitize_filename(project_title)}")
    
    # Create the base output directory if it doesn't exist
    output_base = Path("Software")
    output_base.mkdir(exist_ok=True)
    
    # Create a directory for this project with timestamp prefix
    project_dir_name = f"{timestamp}_{sanitize_filename(project_title)}"
    project_dir = output_base / project_dir_name
    
    # Always create a new project directory
    project_dir.mkdir(exist_ok=True)
    logger.debug(f"Created new project directory: {project_dir}")
    
    # Create subdirectories
    docs_dir = project_dir / "docs"
    src_dir = project_dir / "src"
    tests_dir = project_dir / "tests"
    
    docs_dir.mkdir(exist_ok=True)
    src_dir.mkdir(exist_ok=True)
    tests_dir.mkdir(exist_ok=True)
    
    return project_dir

def save_code_file(project_dir: Path, component_type: str, filename: str, content: str, add_header: bool = True) -> Path:
    """Save a generated code file.
    
    Args:
        project_dir: The project directory path.
        component_type: The type of component (backend, frontend, infrastructure).
        filename: The filename to save.
        content: The content to save.
        add_header: Whether to add a standard file header.
        
    Returns:
        The path to the saved file.
    """
    # Map component type to appropriate directory
    if component_type == "backend":
        base_component_dir = project_dir / "src" / "server"
    elif component_type == "frontend":
        base_component_dir = project_dir / "src" / "client"
    elif component_type == "infrastructure":
        base_component_dir = project_dir / "infra"
    else:
        base_component_dir = project_dir / "src" / component_type
    
    # Create component directory if it doesn't exist
    base_component_dir.mkdir(parents=True, exist_ok=True)
    
    # Special case for HTML files - move them to the right places
    clean_filename = sanitize_filename(Path(filename).name)
    if clean_filename.endswith(".html"):
        if clean_filename == "index.html":
            # Main HTML should be at project root for simple projects
            file_path = project_dir / "index.html"
        else:
            file_path = project_dir / clean_filename
    else:
        # Detect file type for proper organization
        is_css = clean_filename.endswith(".css")
        is_js = clean_filename.endswith(".js")
        is_asset = any(clean_filename.endswith(ext) for ext in [".png", ".jpg", ".jpeg", ".svg", ".gif", ".ico"])
        
        # Organize by file type
        if is_css:
            file_dir = project_dir / "css"
        elif is_js:
            file_dir = project_dir / "js"
        elif is_asset:
            file_dir = project_dir / "assets"
        else:
            # Default to component-specific directory
            file_dir = base_component_dir
        
        file_dir.mkdir(parents=True, exist_ok=True)
        file_path = file_dir / clean_filename
    
    # Normalize content by ensuring consistent line endings and removing BOM
    if isinstance(content, str):
        # Remove any byte order mark if present
        if content.startswith('\ufeff'):
            content = content[1:]
        
        # Normalize line endings
        content = content.replace('\r\n', '\n')
        
        # Fix incomplete HTML files
        if clean_filename.endswith('.html'):
            if '<!DOCTYPE html>' not in content and '<html' not in content:
                # Add proper HTML structure if it's just a fragment
                content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
{content}
<script src="js/game.js"></script>
</body>
</html>"""
        
        # Fix CSS files with just selector content
        if clean_filename.endswith('.css') and '{' not in content and content.strip():
            # It's probably just a selector without the actual CSS block
            content = f"""body {{
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f0f0f0;
}}

{content} {{
    /* Default styling */
    display: block;
    position: relative;
}}
"""
    
    # Add file header if needed and not already present
    if add_header and not content.startswith(('/**', '"""', '<!--', '#')):
        project_name = project_dir.name
        header = get_standard_header(clean_filename, project_name)
        content = header + content
    
    # Write content to file
    with open(file_path, 'w') as f:
        f.write(content)
    
    return file_path

def save_documentation(project_dir: Path, doc_type: str, content: str) -> Path:
    """Save documentation files.
    
    Args:
        project_dir: The project directory path.
        doc_type: The type of documentation (e.g., 'api', 'user_guide').
        content: The documentation content.
        
    Returns:
        The path to the saved file.
    """
    docs_dir = project_dir / "docs"
    docs_dir.mkdir(exist_ok=True)
    
    # Format doc_type as kebab case (e.g., user_guide -> user-guide)
    formatted_doc_type = doc_type.replace('_', '-')
    
    file_path = docs_dir / f"{formatted_doc_type}.md"
    with open(file_path, 'w') as f:
        f.write(content)
    
    return file_path

def save_test_file(project_dir: Path, component_type: str, filename: str, content: str) -> Path:
    """Save a test file.
    
    Args:
        project_dir: The project directory path.
        component_type: The component being tested (backend, frontend, infrastructure).
        filename: The test filename.
        content: The test content.
        
    Returns:
        The path to the saved file.
    """
    tests_dir = project_dir / "tests"
    
    # Ensure test filename follows conventions (e.g., component_name.test.js)
    test_filename = filename
    if not any(pattern in filename for pattern in ['.test.', '.spec.', 'Test', 'Spec']):
        # Add .test before the extension if not already present
        name, ext = os.path.splitext(filename)
        test_filename = f"{name}.test{ext}"
    
    # Create subdirectories based on component type
    component_test_dir = tests_dir / component_type
    component_test_dir.mkdir(parents=True, exist_ok=True)
    
    file_path = component_test_dir / test_filename
    
    # Add file header if not present
    if not content.startswith(('/**', '"""', '<!--', '#')):
        project_name = project_dir.parent.name
        header = get_standard_header(test_filename, project_name)
        content = header + content
    
    with open(file_path, 'w') as f:
        f.write(content)
    
    return file_path

def save_project_metadata(project_dir: Path, metadata: Dict[str, Any]) -> Path:
    """Save project metadata.
    
    Args:
        project_dir: The project directory path.
        metadata: The project metadata.
        
    Returns:
        The path to the saved file.
    """
    file_path = project_dir / "project.json"
    
    # Add timestamp to metadata
    metadata.update({
        "last_updated": datetime.now().isoformat(),
        "version_directory": project_dir.name
    })
    
    with open(file_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    return file_path

def extract_code_blocks(text: str) -> List[Dict[str, str]]:
    """Extract code blocks from markdown-formatted text.
    
    Args:
        text: The text containing markdown code blocks.
        
    Returns:
        A list of dictionaries with file path and content.
    """
    # First, try to find standalone file markers
    standalone_file_pattern = r'# File: ([^\n]+)\n+(.+?)(?=\n+# File:|$)'
    standalone_matches = re.finditer(standalone_file_pattern, text, re.DOTALL)
    standalone_files = []
    
    for match in standalone_matches:
        filename = match.group(1).strip()
        content = match.group(2).strip()
        standalone_files.append({
            "language": filename.split('.')[-1] if '.' in filename else "",
            "filename": filename,
            "content": content
        })
    
    # If we found standalone file markers, use those
    if standalone_files:
        return standalone_files
    
    # If not, use the regular code block pattern
    pattern = r'```(?:(\w+))?(?:\s+([^\n]+))?\n(.*?)```'
    matches = re.finditer(pattern, text, re.DOTALL)
    
    code_blocks = []
    for match in matches:
        language = match.group(1) or ""
        filename = match.group(2) or ""
        content = match.group(3).strip()
        
        # Skip empty blocks
        if not content or len(content.strip()) < 5:
            continue
        
        # Look for filename in the first line of content if not specified in the code fence
        if not filename and content:
            content_lines = content.split('\n')
            first_line = content_lines[0].strip()
            
            # Check for filename indicators in various comment styles
            filename_patterns = [
                r'^\/\*\*?\s*(?:File|Filename):\s*([^*]+)',  # /* File: filename.js */
                r'^\/\/\s*(?:File|Filename):\s*(.+)$',       # // File: filename.js
                r'^#\s*(?:File|Filename):\s*(.+)$',          # # File: filename.js
                r'^<!--\s*(?:File|Filename):\s*([^-]+)',     # <!-- File: filename.html -->
                r'^"""\s*(?:File|Filename):\s*([^"]+)',      # """ File: filename.py
                r'^\/\/ @filename: (.+)$',                   # // @filename: game.js
                r'^\/\/ ([^:]+\.[a-z]+)$',                   # // game.js
            ]
            
            for pattern in filename_patterns:
                file_match = re.search(pattern, first_line, re.IGNORECASE)
                if file_match:
                    filename = file_match.group(1).strip()
                    # Remove the line containing the filename from content
                    content = '\n'.join(content_lines[1:])
                    break
        
        # If we still don't have a filename, use content to determine a default name
        if not filename:
            # Check for content patterns to assign default filenames
            if '<html' in content or '<!DOCTYPE' in content:
                filename = 'index.html'
            elif 'function' in content and ('canvas' in content or 'flappy' in content.lower()):
                filename = 'game.js'
            elif 'body' in content and '{' in content and '}' in content:
                filename = 'styles.css'
            elif language:
                # Use language to determine filename
                if language.lower() in ['js', 'javascript']:
                    filename = 'game.js'
                elif language.lower() in ['css']:
                    filename = 'styles.css'
                elif language.lower() in ['html']:
                    filename = 'index.html'
                else:
                    filename = f'file.{language.lower()}'
        
        # Sanitize the filename
        clean_filename = sanitize_filename(filename)
        
        code_blocks.append({
            "language": language,
            "filename": clean_filename,
            "content": content
        })
    
    return code_blocks

def save_code_blocks_from_text(project_dir: Path, component_type: str, text: str) -> List[Path]:
    """Extract and save code blocks from text.
    
    Args:
        project_dir: The project directory path.
        component_type: The type of component (backend, frontend, infrastructure).
        text: The text containing code blocks.
        
    Returns:
        A list of paths to the saved files.
    """
    code_blocks = extract_code_blocks(text)
    saved_files = []
    
    for block in code_blocks:
        filename = block["filename"]
        content = block["content"]
        
        # Skip empty content or obvious placeholders
        if not content or content.strip() in ["...", "// ..."] or len(content.strip()) < 5:
            continue
            
        file_path = save_code_file(project_dir, component_type, filename, content)
        saved_files.append(file_path)
    
    return saved_files

def process_implementation_output(project_dir: Path, component_type: str, implementation_text: str) -> Dict[str, Any]:
    """Process and save implementation output.
    
    Args:
        project_dir: The project directory path.
        component_type: The type of component (backend, frontend, infrastructure).
        implementation_text: The implementation text containing descriptions and code.
        
    Returns:
        A dictionary with metadata about the saved files.
    """
    # Map component types to standard directories
    if "backend" in component_type:
        doc_prefix = "backend"
    elif "frontend" in component_type:
        doc_prefix = "frontend"
    elif "infrastructure" in component_type or "infra" in component_type:
        doc_prefix = "infrastructure"
    else:
        doc_prefix = component_type
    
    # Save the implementation document itself
    implementation_path = project_dir / "docs" / f"{doc_prefix}-implementation.md"
    implementation_path.parent.mkdir(exist_ok=True)
    
    with open(implementation_path, 'w') as f:
        f.write(implementation_text)
    
    # Extract and save code blocks
    saved_files = save_code_blocks_from_text(project_dir, component_type, implementation_text)
    
    return {
        "implementation_doc": str(implementation_path),
        "saved_files": [str(path) for path in saved_files],
        "component_type": component_type
    }

def create_or_update_project_log(project_dir: Path, event_type: str, agent_name: str, 
                                description: str, details: Optional[Dict[str, Any]] = None) -> Path:
    """Create or update the project log file.
    
    This maintains a running log of significant events in the project
    in markdown format, similar to a journal.
    
    Args:
        project_dir: The project directory path
        event_type: The type of event (architecture-design, implementation, etc.)
        agent_name: The name of the agent
        description: Description of the event
        details: Additional details about the event
        
    Returns:
        Path to the project log file
    """
    if isinstance(project_dir, str):
        project_dir = Path(project_dir)
        
    log_file = project_dir / "project.log.md"
    
    # Format current time
    now = datetime.now()
    timestamp = now.strftime("%Y-%m-%d %H:%M:%S")
    
    # Create the header of the log file if it doesn't exist
    if not log_file.exists():
        header = "# Project Log\n\n"
        header += f"Project directory: {project_dir}\n\n"
        header += "| Timestamp | Event Type | Agent | Description | Details |\n"
        header += "|-----------|------------|-------|-------------|---------|"
        with open(log_file, 'w') as f:
            f.write(header + "\n")
            
    # Format details
    if details:
        details_str = "<br>".join([f"{k}: {v}" for k, v in details.items()])
    else:
        details_str = ""
        
    # Format the event entry
    entry = f"| {timestamp} | {event_type} | {agent_name} | {description} | {details_str} |\n"
    
    # Append the entry to the log file
    with open(log_file, 'a') as f:
        f.write(entry)
        
    # Log that we've updated the project log
    logger.debug(f"Updated project log: {event_type} - {description}")
    
    # Support different agent types with specific event handlers
    try:
        # Map agent types to their corresponding directories
        agent_type = agent_name.lower()
        if agent_type.endswith('qa') or 'qa-' in agent_type or 'qa_' in agent_type:
            # QA agent events
            if event_type == "qa-testing" and "test_file" in details:
                test_file = details.get("test_file", "")
                logger.info(f"QA agent {agent_name} produced test file: {test_file}")
        elif agent_type.endswith('developer') or 'developer-' in agent_type or agent_type.endswith('engineer'):
            # Developer/Engineer agent events
            if event_type in ["implementation", "code-implementation"] and "file" in details:
                code_file = details.get("file", "")
                logger.info(f"Developer agent {agent_name} produced code file: {code_file}")
        elif agent_type.startswith('ui') or 'designer' in agent_type:
            # UI Designer agent events
            if event_type == "ui-design" and "ui_file" in details:
                ui_file = details.get("ui_file", "")
                logger.info(f"UI Designer agent {agent_name} produced UI design: {ui_file}")
        elif agent_type.startswith('security') or 'security_' in agent_type:
            # Security Engineer agent events
            if event_type == "security-analysis" and "security_file" in details:
                security_file = details.get("security_file", "")
                logger.info(f"Security Engineer agent {agent_name} produced security analysis: {security_file}")
        elif agent_type.startswith('tech') or 'writer' in agent_type or 'document' in agent_type:
            # Technical Writer agent events
            if event_type == "documentation" and ("doc_file" in details or "readme_file" in details):
                doc_file = details.get("doc_file", "")
                readme_file = details.get("readme_file", "")
                logger.info(f"Technical Writer agent {agent_name} produced documentation: {doc_file or readme_file}")
    except Exception as e:
        logger.error(f"Error handling specific agent event: {str(e)}")
        
    return log_file

def create_or_update_agent_log(
    project_dir: Union[Path, str], 
    agent_name: str, 
    action_type: str, 
    input_summary: Any,
    output_summary: Any,
    details: Optional[Dict[str, Any]] = None,
    log_format: str = "markdown"
) -> Path:
    """Create or update the agent log file in Markdown or JSON format.
    
    This creates a detailed log of agent actions separately from the project log,
    allowing for more detailed tracking of agent behavior.
    
    Args:
        project_dir: The project directory path (Path object or string).
        agent_name: The name of the agent performing the action.
        action_type: The type of action being performed (e.g., 'analyze', 'generate', 'review').
        input_summary: The input to the agent (any type).
        output_summary: The output from the agent (any type).
        details: Optional additional details about the action.
        log_format: Format for logging - "markdown" or "json"
        
    Returns:
        The path to the agent log file.
    """
    # Ensure project_dir is a Path object
    if isinstance(project_dir, str):
        logger.debug(f"Converting project_dir from string to Path: '{project_dir}'")
        project_dir = Path(project_dir)
    else:
        logger.debug(f"Project dir is already a Path object: {type(project_dir)}")
        
    logger.debug(f"Creating/updating agent log for agent '{agent_name}', action '{action_type}' in dir {project_dir}")
    
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    if log_format.lower() == "json":
        return _create_or_update_json_agent_log(
            project_dir, agent_name, action_type, input_summary, 
            output_summary, details, timestamp
        )
    else:  # Default to markdown
        return _create_or_update_markdown_agent_log(
            project_dir, agent_name, action_type, input_summary, 
            output_summary, details, timestamp
        )

def _create_or_update_markdown_agent_log(
    project_dir: Union[Path, str], 
    agent_name: str, 
    action_type: str, 
    input_summary: Any,
    output_summary: Any,
    details: Optional[Dict[str, Any]] = None,
    timestamp: str = None
) -> Path:
    """Create or update agent log in Markdown format."""
    # Ensure project_dir is a Path object
    if isinstance(project_dir, str):
        logger.debug(f"Converting project_dir from string to Path in markdown log: '{project_dir}'")
        project_dir = Path(project_dir)
        
    log_path = project_dir / "agent.log.md"
    logger.debug(f"Using log path: {log_path}")
    timestamp = timestamp or datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Create header if file doesn't exist
    if not log_path.exists():
        logger.debug(f"Creating new markdown agent log file at {log_path}")
        header = f"# Agent Activity Log\n\n"
        header += f"Project directory: {project_dir}\n\n"
        header += f"| Timestamp | Agent | Action | Input | Output | Details |\n"
        header += f"|-----------|-------|--------|-------|--------|--------|\n"
        content = header
    else:
        logger.debug(f"Updating existing markdown agent log file at {log_path}")
        with open(log_path, 'r') as f:
            content = f.read()
    
    # Format details as a string if present
    details_str = ""
    if details:
        details_list = []
        for key, value in details.items():
            # Ensure value is properly formatted for markdown table
            value_str = str(value).replace("\n", "<br>")
            details_list.append(f"{key}: {value_str}")
        details_str = "<br>".join(details_list)
    
    # Convert input and output to proper string representations
    # Handle different types appropriately
    input_str = _format_for_markdown(input_summary)
    output_str = _format_for_markdown(output_summary)
    
    # Add new log entry
    log_entry = f"| {timestamp} | {agent_name} | {action_type} | {input_str} | {output_str} | {details_str} |\n"
    content += log_entry
    
    # Write updated content
    with open(log_path, 'w') as f:
        f.write(content)
    
    return log_path

def _create_or_update_json_agent_log(
    project_dir: Union[Path, str], 
    agent_name: str, 
    action_type: str, 
    input_summary: Any,
    output_summary: Any,
    details: Optional[Dict[str, Any]] = None,
    timestamp: str = None
) -> Path:
    """Create or update agent log in JSON format."""
    # Ensure project_dir is a Path object
    if isinstance(project_dir, str):
        logger.debug(f"Converting project_dir from string to Path in JSON log: '{project_dir}'")
        project_dir = Path(project_dir)
        
    log_path = project_dir / "agent.log.json"
    logger.debug(f"Using JSON log path: {log_path}")
    timestamp = timestamp or datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Read existing logs or create empty list
    if log_path.exists():
        try:
            with open(log_path, 'r') as f:
                logs = json.load(f)
        except json.JSONDecodeError:
            # Handle corrupted JSON file
            logs = {"logs": []}
    else:
        logs = {"logs": []}
    
    # Create new log entry
    log_entry = {
        "timestamp": timestamp,
        "agent": agent_name,
        "action": action_type,
        "input": input_summary,  # Will be serialized by json.dump
        "output": output_summary,  # Will be serialized by json.dump
        "details": details or {}
    }
    
    # Add new entry to logs
    logs["logs"].append(log_entry)
    
    # Write updated content
    with open(log_path, 'w') as f:
        json.dump(logs, f, indent=2, default=str)  # Use default=str for non-serializable objects
    
    return log_path

def _format_for_markdown(value: Any) -> str:
    """Format any value type for markdown table representation."""
    if value is None:
        return ""
    
    # Convert to string representation
    if isinstance(value, dict):
        # For dictionaries, try to make a compact representation
        if len(str(value)) > 100:
            # Summarize long dictionaries
            num_keys = len(value)
            first_key = next(iter(value)) if value else ""
            return f"Dict with {num_keys} keys including '{first_key}'"
        else:
            value_str = str(value)
    elif isinstance(value, (list, tuple)):
        # For lists/tuples
        if len(str(value)) > 100:
            return f"List with {len(value)} items"
        else:
            value_str = str(value)
    elif isinstance(value, str):
        # For strings, check if it's multiline
        if "\n" in value:
            # Replace newlines with HTML breaks
            value_str = value.replace("\n", "<br>")
            # If very long, truncate
            if len(value_str) > 2000:
                chars = len(value)
                lines = value.count("\n") + 1
                value_str = f"(Multi-line text: {lines} lines, {chars} chars)"
        else:
            value_str = value
    else:
        # For other types
        value_str = str(value)
    
    # Escape pipe characters to not break markdown table
    value_str = value_str.replace("|", "\\|")
    
    return value_str 